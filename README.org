* Meyvn 

#+BEGIN_QUOTE
You Know Nothing, Jon Snow. — Ygritte
#+END_QUOTE

The word maven comes from the Yiddish meyvn, meaning one who understands. You can think of Meyvn as: 

- A build tool
- A wrapper for Maven
- A ~tools.deps~ extension.

Meyvn enables you to generate uberjars (executables) and jars (libraries), and to deploy them on remote servers, Clojars, etc.

** Goals

- Use ~deps.edn~ as single source of truth. 

- One command to do it all: compile, package, install on a remote server, etc.

- Lightweight. It only depends on Clojure and Maven (with no external dependencies).

- Ability to selectively shrink uberjars

** Features

- Up to 30% smaller uberjars
- Leverages the Maven ecosystem
- Clojurescript compilation relies on the official compiler
- Clojurescript compilation takes advantage of the shared aot cache. 

** Installation

- Meyvn requires Maven. Make sure it is installed on your system.
- Define an alias in ~$HOME/.clojure/deps.edn~:

#+BEGIN_SRC clojure
:aliases {:meyvn
          {:extra-deps {org.danielsz/meyvn {:mvn/version "1.0.0"}}}
          ...}
#+END_SRC

- Create an executable shell script in your path.

#+BEGIN_SRC sh
$ touch /usr/local/bin/myvn
#+END_SRC

Make sure it contains the following.
#+BEGIN_SRC sh
$ cat /usr/local/bin/myvn
#!/bin/sh
M2_HOME=/usr/local clj -A:meyvn -m meyvn.core "$@"
#+END_SRC

~M2_HOME~ points to the root of your Maven installation directory. Strictly speaking, Maven can run without this environment variable, but the provided APIs require it in order to find the executable (~/bin/mvn~). 

~clj~ is the standard runner that ships with the [[https://clojure.org/guides/getting_started][Clojure installer and CLI tools]]. ~$@~ references the arguments passed to the script.

Set the executable bit. 
#+BEGIN_SRC 
$ chmod +x /usr/local/bin/myvn
#+END_SRC

** Usage

The standard Maven lifecycle phases and goals are passed as arguments. There’s [[https://maven.apache.org/guides/][documentation]], too. 

For example: 

#+BEGIN_SRC 
myvn compile 
#+END_SRC 

Or 

#+BEGIN_SRC 
myvn package
#+END_SRC 

Or 

#+BEGIN_SRC 
myvn deploy
#+END_SRC 

** Debugging the build

If you see errors with the build, run ~myvn -g~. This will persist Meyvn’s pom file. You can now run ~mvn~ on it and debug as you normally would in Maven. You will need to specify the path to the pom file.

#+BEGIN_SRC sh
mvn -f meyvn-pom.xml <goal>
#+END_SRC

** Configuration

Configuration is stored in ~meyvn.edn~, which will be created in the root of your project on first run. 

Here are the defaults, but suit your needs.

#+BEGIN_SRC clojure
{:pom {:group-id "com.changeme"
       :artifact-id "myproject"
       :version "1.0.0"
       :name "My project does a lot"}
 :packaging {:uberjar 
             {:enabled true
              :main-class "main.core"
              :remote-repository {:id "ssh-repository"
                                  :url "scpexe://user@domain:/home/.m2/repository"}
              :excludes {:sets ["org.clojure:google-closure-library"]
                         :filters ["META-INF/*.MF" "META-INF/*.SF" "META-INF/*.DSA" "META-INF/*.RSA"]}}             
             :jar
             {:enabled false
              :remote-repository {:id "clojars"
                                  :url "https://clojars.org/repo"}}}
 :cljs {:enabled false
        :main-class "main.core"
        :compiler-opts {:optimizations :advanced
                        :output-wrapper true
                        :infer-externs true
                        :parallel-build true
                        :aot-cache true
                        :output-to "resources/js/main.js"}
        :tools-deps-alias :cljs}}
#+END_SRC

Aside from the ~:pom~ key which captures the project coordinates and is always used, the other keys can be enabled or disabled as needed.

** How does it work?

~tools.deps~ has the built-in capability to generate a pom file (~clj -Spom~). Meyvn starts off from that pom file and augments it with features that make sense for Clojure workflows. Meyvn’s pom file is transient and does not interfere with POM files that may already be present in your project. 

Maven is invoked via an API (~Apache Maven Invoker~) and can be passed all lifecycle phases or goal it supports. 

Clojurescript sources are compiled and included in the final artifact. Clojurescript compilation is done in its own process with the official compiler.

*** Uberjars

Consider the following deps.edn file: 

#+BEGIN_SRC clojure
{:paths ["src/clj"]
 :deps {org.clojure/core.async {:mvn/version "0.4.474"}
        ring {:mvn/version "1.6.3"}
        compojure {:mvn/version "1.6.1"}}
 :aliases {:cljs {:extra-deps {org.clojure/clojurescript {:mvn/version "1.10.238"}
                               reagent {:mvn/version "0.8.1"} 
                               secretary {:mvn/version "1.2.3"}}
                  :extra-paths ["src/cljs"]}}}
#+END_SRC

The Clojurescript-side of the mixed project is cleanly segregated. The ~:cljs~ alias is used when compiling the ~*.cljs~ files, but not when assembling the uberjar, helping to keep the latter small. You tell Meyvn to use this alias in the ~meyvn.edn~ configuration, under the ~cljs~ -> ~tools-deps-alias~ keys.

Meyvn uses the Apache Maven Shade Plugin in order to build uberjars.

The Shade plugin has advanced capabilities that are not used, such as class relocation. 

#+BEGIN_QUOTE
Shading dependencies is the process of including and renaming dependencies (thus relocating the classes & rewriting affected bytecode & resources) to create a private copy that you bundle alongside your own code. But the shading part is actually optional: the plugin allows to include dependencies in your jar (fat jar), and optionally rename (shade) dependencies.
#+END_QUOTE

However, Meyvn gives you access to the exclusions facility provided by the Shade plugin, equivalent to Leiningen’s [[https://github.com/technomancy/leiningen/blob/cee9029d15719058d39b4ccc30de2e0975f07f8a/sample.project.clj#L418][uberjar-exclusions]] or Boot’s 
[[https://github.com/boot-clj/boot/blob/e6ea562af765ee2b50703ab33a00cf615d0bef43/boot/pod/src/boot/pod.clj#L627][standard-jar-exclusions]].

#+BEGIN_SRC clojure
:excludes {:artifacts ["org.clojure:google-closure-library"]
           :filters ["META-INF/*.MF" "META-INF/*.SF" "META-INF/*.DSA" "META-INF/*.RSA"]}
#+END_SRC

Note that you don’t need to exclude ~INDEX/LIST~ as this is [[https://github.com/intelie/maven-shade-plugin/blob/71b5895028f9c9ca2730b45d1117d8e6d3372a3e/src/main/java/org/apache/maven/plugins/shade/DefaultShader.java#L137][built-in]] by the Shade plugin.

Additionally, Meyvn allows you to exclude artifacts. It is possible that the Closure library is transitively pulled in your final uberjar, and that may not make sense.

Data readers are merged with a [[https://github.com/danielsz/shade-edn-transformer][custom transformer]] that knows how to merge EDN maps. 

*** Regular jars

Libraries uploaded to Clojars are typically non-aot, source-only jars. Uploading to Clojars follows [[https://github.com/clojars/clojars-web/wiki/Pushing#maven][standard procedure]]. Use ~settings.xml~ for storing your credentials.
 
*** Pom files

Meyvn works with its own set of pom files. It isn’t bothered with existing pom files in your project directory. This is by design. The single source of truth is ~deps.edn~. Together with the configuration (in ~meyvn.edn~), it knows all that it needs to know.

The added benefit is that you can continue to maintain your pom file if you are already using a Maven workflow. 

*** Dependency mechanism

The transitive dependency mechanism used by Maven is guided by the nearest wins conflict resolution strategy.
This allows for resolution of individual conflicts: for any particular conflicting dependency, you can specify its version within your own POM, and that version becomes the nearest.

#+BEGIN_QUOTE
Note that if two dependency versions are at the same depth in the dependency tree, until Maven 2.0.8 it was not defined which one would win, but since Maven 2.0.9 it's the order in the declaration that counts: the first declaration wins.
#+END_QUOTE

** Will it work?

It should work for the typical Clojure workflows. Please feel free to contact me in private if you want help solving your company’s build workflow.


Windows is not supported (where the Clojure command line tools are not available).  

Feel free to open issues. but I will not look at them unless you’re a sponsor. Feel free to submit a PR if you don’t mind seeing it languish in the queue.

Be a mensch. [[https://www.patreon.com/danielsz][Patronize]] my tuchus.

** What about Boot and Leiningen?

What about them?

** Literature

- [[http://nealford.com/memeagora/2013/01/22/why_everyone_eventually_hates_maven.html][Why Everyone (Eventually) Hates (or Leaves) Maven]]
- [[https://rule1.quora.com/Use-Maven-Not-Gradle][Use Maven, Not Gradle]]
